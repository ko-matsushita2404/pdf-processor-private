import streamlit as st
import os
import tempfile
import zipfile
import io
import traceback
from datetime import datetime
import re
import csv
import pytesseract
from pdf2image import convert_from_bytes
from PIL import Image

# ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰è¨­å®š
PDF_PASSWORD = 'hyoki'

# èªè¨¼æ©Ÿèƒ½
def check_password():
    def password_entered():
        if st.session_state["password"] == "your_secret_password":
            st.session_state["password_correct"] = True
            del st.session_state["password"]
        else:
            st.session_state["password_correct"] = False

    if "password_correct" not in st.session_state:
        st.text_input("ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„", type="password", 
                     on_change=password_entered, key="password")
        return False
    elif not st.session_state["password_correct"]:
        st.text_input("ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„", type="password", 
                     on_change=password_entered, key="password")
        st.error("ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãŒæ­£ã—ãã‚ã‚Šã¾ã›ã‚“")
        return False
    else:
        return True

# CSVãƒ˜ãƒƒãƒ€ãƒ¼å®šç¾©
CSV_HEADERS = [
    'è£½ç•ª', 'å›³ç•ª', 'éƒ¨ç•ª', 'ç¬¦å·', 'å“å', 'ï¾’ï½°ï½¶å', 'æè³ªå', 'å½¢å¼å¯¸æ³•', 'é‡é‡ï¼ˆkgï¼‰', 'å“¡æ•°', 'å˜ä½',
    'ç™ºæ³¨æ•°é‡', 'å˜ä½', 'æ‰‹é…ï½ºï½°ï¾„ï¾', 'ç´æœŸ', 'ä»•å…¥å…ˆï½ºï½°ï¾„ï¾', 'ç™ºæ³¨å˜ä¾¡', 'é‡‘é¡', 'ç´å…¥å ´æ‰€', 'å‚™è€ƒ', 
    'TECHSå˜ä¾¡åŒºåˆ†', 'TECHSå®Œäº†CK', 'TECHSç™ºæ³¨æƒ…å ±å–è¾¼CK'
]

# OCRå‡¦ç†é–¢æ•°
def perform_ocr_web(pdf_bytes, filename):
    """PDF bytesã‹ã‚‰OCRã§ãƒ†ã‚­ã‚¹ãƒˆã‚’æŠ½å‡º"""
    try:
        # PDFã‚’ç”»åƒã«å¤‰æ›
        images = convert_from_bytes(pdf_bytes, userpw=PDF_PASSWORD)
        
        full_text = ""
        for i, image in enumerate(images):
            # æ—¥æœ¬èªOCRå®Ÿè¡Œ
            text = pytesseract.image_to_string(image, lang='jpn')
            full_text += f"--- Page {i+1} ---\n"
            full_text += text
            full_text += "\n"
            
        return full_text
    except Exception as e:
        st.error(f"OCRå‡¦ç†ã§ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: {str(e)}")
        return None

# å…µæ©Ÿæµ·é‹è«‹æ±‚æ›¸ãƒ‡ãƒ¼ã‚¿æŠ½å‡ºé–¢æ•°
def extract_hyoki_kaiun_data(ocr_text):
    """å…µæ©Ÿæµ·é‹è«‹æ±‚æ›¸ã‹ã‚‰ãƒ‡ãƒ¼ã‚¿ã‚’æŠ½å‡º"""
    extracted_rows_asterisk = []
    extracted_rows_no_asterisk = []
    main_seiban = ''
    invoice_no = ''
    delivery_date = ''

    # è£½ç•ªæŠ½å‡º
    match_seiban_header = re.search(r'è£½ç•ª:\s*(\S+)', ocr_text)
    if match_seiban_header:
        main_seiban = match_seiban_header.group(1)

    # è«‹æ±‚æ›¸ç•ªå·æŠ½å‡º
    match_invoice_no = re.search(r'è«‹æ±‚N\)\s*:\s*([A-Z0-9-]+)', ocr_text)
    if match_invoice_no:
        invoice_no = match_invoice_no.group(1)

    # ç´æœŸæŠ½å‡º
    match_delivery_date = re.search(r'è«‹æ±‚æ—¥\s*:\s*(\d{4}/\d{2}/\d{2})', ocr_text)
    if match_delivery_date:
        delivery_date = match_delivery_date.group(1)

    remarks_text = f"è²´ç¤¾è«‹æ±‚æ›¸NO.{invoice_no}ã«ä¾ã‚Šã¾ã™ã€‚" if invoice_no else ''

    lines = ocr_text.splitlines()

    # ã€Œ* å°ã¯èª²ç¨å¯¾è±¡å–å¼•ã§ã™ã€ã®è¡Œã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’è¦‹ã¤ã‘ã‚‹
    effective_end_index = len(lines)
    for idx, line in enumerate(lines):
        if "* å°ã¯èª²ç¨å¯¾è±¡å–å¼•ã§ã™" in line:
            effective_end_index = idx
            break

    # è¡Œé …ç›®ã®æ­£è¦è¡¨ç¾ãƒ‘ã‚¿ãƒ¼ãƒ³
    line_item_regex = re.compile(
        r'^\*?\s*(.+?)\s+(\d+(?:[.,]\d+)?)\s+(\S+)\s+JPY([\d,\s.]+)\s*(JPY[\d,\s.]*)?$'
    )

    # å½¢å¼å¯¸æ³•ã®ãƒ‘ã‚¿ãƒ¼ãƒ³
    dimension_patterns = [
        re.compile(r'^\d+FT(?: OPEN TOP)?$'),
        re.compile(r'^\d+/\d+\s*\((?:ãƒˆãƒ¬ãƒ¼ãƒ©ãƒ¼|ã‚³ãƒ³ãƒ†ãƒŠ|æ··è¼‰ä¾¿)\)$'),
        re.compile(r'^\S+\s*\(\s*\d+TON\s*\)$'),
        re.compile(r'^\d+å“ç›®=\d+ç”³å‘Š$'),
        re.compile(r'^\d+TON$'),
    ]

    i = 0
    while i < effective_end_index:
        line = lines[i]

        match = line_item_regex.search(line)
        if match:
            hinmei = match.group(1).strip()
            inzu = match.group(2)
            tani = match.group(3)
            hacchu_tanka = match.group(4).replace(',', '').replace(' ', '')
            kingaku_str = match.group(5) if match.group(5) else ''
            kingaku = kingaku_str.replace('JPY', '').replace(',', '').replace(' ', '').strip()
            keishiki_sunpou = ''

            # OCRèª¤èªè­˜ã®ç½®æ›ãƒ«ãƒ¼ãƒ«
            replacement_rules = {
                'ãƒã‚³ãƒƒãƒ†ãƒŠé‹æ¬æ–™': 'ï½ºï¾ï¾ƒï¾…ï½°é‹æ¬æ–™',
                'ãƒˆã†9è³ƒ': 'ï¾„ï¾—ï½¯ï½¸è³ƒ',
                'ãƒ«ãƒ¼ãƒƒä»£': 'ï½¸ï¾šï½°ï¾ä»£',
                'aç¤¾è²»ç”¨(ç«‹æ›¿)': 'èˆ¹ç¤¾è²»ç”¨(ç«‹æ›¿)',
            }

            hinmei = replacement_rules.get(hinmei, hinmei)

            # æ¬¡ã®è¡ŒãŒå½¢å¼å¯¸æ³•ã‹ãƒã‚§ãƒƒã‚¯
            if i + 1 < len(lines):
                next_line = lines[i+1].strip()
                for pattern in dimension_patterns:
                    if pattern.search(next_line):
                        keishiki_sunpou = next_line
                        i += 1
                        break

            row_data = {
                'è£½ç•ª': main_seiban,
                'å“å': hinmei,
                'å“¡æ•°': inzu,
                'å˜ä½': tani,
                'ç™ºæ³¨å˜ä¾¡': hacchu_tanka,
                'é‡‘é¡': kingaku,
                'å½¢å¼å¯¸æ³•': keishiki_sunpou,
                'å‚™è€ƒ': remarks_text,
                'æ‰‹é…ï½ºï½°ï¾„ï¾': '3411',
                'ç´æœŸ': delivery_date,
                'ä»•å…¥å…ˆï½ºï½°ï¾„ï¾': '80129',
                'ç´å…¥å ´æ‰€': 'æ»å·å·¥æ¥­ãˆ±\tæœ¬ç¤¾å·¥å ´',
                'TECHSå˜ä¾¡åŒºåˆ†': 'S0',
                'TECHSå®Œäº†CK': 'S1',
                'TECHSç™ºæ³¨æƒ…å ±å–è¾¼CK': 'S1',
            }

            if line.strip().startswith('*'):
                extracted_rows_asterisk.append(row_data)
            else:
                row_data['å“å'] = f"{row_data['å“å']}ï¼ˆå…ç¨ï¼‰"
                extracted_rows_no_asterisk.append(row_data)

        i += 1

    return extracted_rows_asterisk, extracted_rows_no_asterisk

# CSVç”Ÿæˆé–¢æ•°
def generate_csv_data(extracted_rows):
    """æŠ½å‡ºã—ãŸãƒ‡ãƒ¼ã‚¿ã‚’CSVå½¢å¼ã§ç”Ÿæˆ"""
    if not extracted_rows:
        return None
    
    output = io.StringIO()
    final_data = []
    
    for row_raw in extracted_rows:
        new_row = {header: '' for header in CSV_HEADERS}
        new_row.update(row_raw)
        final_data.append(new_row)
    
    writer = csv.DictWriter(output, fieldnames=CSV_HEADERS)
    writer.writeheader()
    writer.writerows(final_data)
    
    return output.getvalue()

# ãƒ¡ã‚¤ãƒ³å‡¦ç†é–¢æ•°
def process_pdf_file(pdf_file):
    """å˜ä¸€PDFãƒ•ã‚¡ã‚¤ãƒ«ã®å‡¦ç†"""
    try:
        # OCRå‡¦ç†
        pdf_bytes = pdf_file.read()
        ocr_text = perform_ocr_web(pdf_bytes, pdf_file.name)
        
        if not ocr_text:
            return None, None, None
        
        # ãƒ‡ãƒ¼ã‚¿æŠ½å‡º
        extracted_rows_asterisk, extracted_rows_no_asterisk = extract_hyoki_kaiun_data(ocr_text)
        
        # CSVç”Ÿæˆ
        csv_asterisk = generate_csv_data(extracted_rows_asterisk) if extracted_rows_asterisk else None
        csv_no_asterisk = generate_csv_data(extracted_rows_no_asterisk) if extracted_rows_no_asterisk else None
        
        return ocr_text, csv_asterisk, csv_no_asterisk
        
    except Exception as e:
        st.error(f"å‡¦ç†ã‚¨ãƒ©ãƒ¼: {str(e)}")
        return None, None, None

# ãƒ¡ã‚¤ãƒ³ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³
def main():
    st.set_page_config(
        page_title="PDFå‡¦ç†ã‚·ã‚¹ãƒ†ãƒ ",
        page_icon="ğŸ“„",
        layout="wide"
    )
    
    if not check_password():
        return
    
    st.title("ğŸ“„ PDFå‡¦ç†ã‚·ã‚¹ãƒ†ãƒ ")
    st.markdown("å…µæ©Ÿæµ·é‹è«‹æ±‚æ›¸PDFã‹ã‚‰ãƒ‡ãƒ¼ã‚¿ã‚’æŠ½å‡ºã—ã¦CSVãƒ•ã‚¡ã‚¤ãƒ«ã‚’ç”Ÿæˆã—ã¾ã™ã€‚")
    
    # ãƒ•ã‚¡ã‚¤ãƒ«ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰
    uploaded_files = st.file_uploader(
        "PDFãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠã—ã¦ãã ã•ã„ï¼ˆè¤‡æ•°é¸æŠå¯èƒ½ï¼‰",
        type=['pdf'],
        accept_multiple_files=True
    )
    
    if uploaded_files:
        st.success(f"{len(uploaded_files)}å€‹ã®ãƒ•ã‚¡ã‚¤ãƒ«ãŒé¸æŠã•ã‚Œã¾ã—ãŸã€‚")
        
        if st.button("å‡¦ç†é–‹å§‹", type="primary"):
            progress_bar = st.progress(0)
            results = []
            
            for i, uploaded_file in enumerate(uploaded_files):
                st.write(f"å‡¦ç†ä¸­: {uploaded_file.name}")
                
                # PDFãƒ•ã‚¡ã‚¤ãƒ«å‡¦ç†
                ocr_text, csv_asterisk, csv_no_asterisk = process_pdf_file(uploaded_file)
                
                if ocr_text:
                    results.append({
                        'filename': uploaded_file.name,
                        'ocr_text': ocr_text,
                        'csv_asterisk': csv_asterisk,
                        'csv_no_asterisk': csv_no_asterisk
                    })
                    st.success(f"âœ… {uploaded_file.name} å‡¦ç†å®Œäº†")
                else:
                    st.error(f"âŒ {uploaded_file.name} å‡¦ç†å¤±æ•—")
                
                progress_bar.progress((i + 1) / len(uploaded_files))
            
            # çµæœè¡¨ç¤º
            st.markdown("## å‡¦ç†çµæœ")
            
            if results:
                # ZIPå½¢å¼ã§ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰
                zip_buffer = io.BytesIO()
                with zipfile.ZipFile(zip_buffer, 'w', zipfile.ZIP_DEFLATED) as zip_file:
                    for result in results:
                        base_name = os.path.splitext(result['filename'])[0]
                        
                        # OCRãƒ†ã‚­ã‚¹ãƒˆ
                        zip_file.writestr(f"{base_name}_ocr_text.txt", result['ocr_text'])
                        
                        # CSVï¼ˆèª²ç¨å¯¾è±¡ï¼‰
                        if result['csv_asterisk']:
                            zip_file.writestr(f"{base_name}_asterisk.csv", result['csv_asterisk'])
                        
                        # CSVï¼ˆå…ç¨ï¼‰
                        if result['csv_no_asterisk']:
                            zip_file.writestr(f"{base_name}_no_asterisk.csv", result['csv_no_asterisk'])
                
                zip_buffer.seek(0)
                
                st.download_button(
                    label="ğŸ“¥ çµæœã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ï¼ˆZIPå½¢å¼ï¼‰",
                    data=zip_buffer.getvalue(),
                    file_name=f"pdf_processing_results_{datetime.now().strftime('%Y%m%d_%H%M%S')}.zip",
                    mime="application/zip"
                )
                
                # å€‹åˆ¥ãƒ•ã‚¡ã‚¤ãƒ«è¡¨ç¤º
                for result in results:
                    with st.expander(f"ğŸ“„ {result['filename']} ã®è©³ç´°"):
                        
                        # OCRãƒ†ã‚­ã‚¹ãƒˆè¡¨ç¤º
                        st.subheader("OCRãƒ†ã‚­ã‚¹ãƒˆ")
                        st.text_area(
                            "æŠ½å‡ºã•ã‚ŒãŸãƒ†ã‚­ã‚¹ãƒˆ",
                            result['ocr_text'],
                            height=200,
                            key=f"ocr_{result['filename']}"
                        )
                        
                        # CSVè¡¨ç¤º
                        col1, col2 = st.columns(2)
                        
                        with col1:
                            if result['csv_asterisk']:
                                st.subheader("èª²ç¨å¯¾è±¡ãƒ‡ãƒ¼ã‚¿")
                                st.download_button(
                                    label="CSVãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰",
                                    data=result['csv_asterisk'],
                                    file_name=f"{os.path.splitext(result['filename'])[0]}_asterisk.csv",
                                    mime="text/csv"
                                )
                        
                        with col2:
                            if result['csv_no_asterisk']:
                                st.subheader("å…ç¨ãƒ‡ãƒ¼ã‚¿")
                                st.download_button(
                                    label="CSVãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰",
                                    data=result['csv_no_asterisk'],
                                    file_name=f"{os.path.splitext(result['filename'])[0]}_no_asterisk.csv",
                                    mime="text/csv"
                                )
            else:
                st.warning("å‡¦ç†ã«æˆåŠŸã—ãŸãƒ•ã‚¡ã‚¤ãƒ«ãŒã‚ã‚Šã¾ã›ã‚“ã€‚")

if __name__ == "__main__":
    main()
